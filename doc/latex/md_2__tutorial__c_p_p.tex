\subsection*{量子状態}

\subsubsection*{量子状態の生成}

以下のコードで{\ttfamily n}qubitの量子状態を生成します。 生成した量子状態は $|0\rangle^{\otimes n}$ に初期化されています。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{comment}{// 5-qubitの状態を生成}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    \textcolor{comment}{// |00000>に初期化}}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 メモリが不足している場合はプログラムが終了します。

\subsubsection*{量子状態の初期化}

生成した量子状態は、計算基底に初期化したり、ランダムな状態に初期化することが出来ます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} test() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{    \textcolor{comment}{// |00101>に初期化}}
\DoxyCodeLine{    state.set\_computational\_basis(0b00101);}
\DoxyCodeLine{    \textcolor{comment}{// ランダムな初期状態を生成}}
\DoxyCodeLine{    state.set\_Haar\_random\_state();}
\DoxyCodeLine{    \textcolor{comment}{// シードを指定してランダムな初期状態を生成}}
\DoxyCodeLine{    state.set\_Haar\_random\_state(0);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{量子状態のデータのコピーとロード}

量子状態を複製したり、他の量子状態のデータをロードできます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_computational\_basis(0b00101);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// コピーして新たな量子状態を作成}}
\DoxyCodeLine{    \textcolor{keyword}{auto} second\_state = state.copy();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 量子状態を新たに生成し、既存の状態のベクトルをコピー}}
\DoxyCodeLine{    QuantumState third\_state(n);}
\DoxyCodeLine{    third\_state.load(\&state);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{古典レジスタの操作}

量子状態は古典レジスタを持っており、読み書きを行えます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// registerの書き込み}}
\DoxyCodeLine{    \textcolor{keywordtype}{int} register\_position = 3;}
\DoxyCodeLine{    \textcolor{keywordtype}{int} register\_value = 1;}
\DoxyCodeLine{    state.set\_classical\_bit(register\_position, register\_value);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// registerの読み出し}}
\DoxyCodeLine{    \textcolor{keywordtype}{int} obtained\_value;}
\DoxyCodeLine{    obtained\_value = state.get\_classical\_bit(register\_position);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{量子状態に関する計算}

量子状態を変えない計算として、以下の処理が可能です。 量子状態を変える計算は必ず量子ゲート、量子回路を介して行われます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// normの計算}}
\DoxyCodeLine{    \textcolor{keywordtype}{double} norm = state.get\_norm(); }
\DoxyCodeLine{    \textcolor{comment}{// Z基底で測定した時のentropyの計算}}
\DoxyCodeLine{    \textcolor{keywordtype}{double} entropy = state.get\_entropy(); }
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// index-th qubitをZ基底で測定して0を得る確率の計算}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keywordtype}{double} zero\_prob = state.get\_zero\_prob(index);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 周辺確率を計算 (以下は0,3-th qubitが0、1,2-th qubitが1と測定される確率の例)}}
\DoxyCodeLine{    std::vector<unsigned int> value\_list = \{0,1,1,0,2\};}
\DoxyCodeLine{    \textcolor{keywordtype}{double} marginal\_prob = state.get\_marginal\_prob(value\_list);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{量子状態の内積}

{\ttfamily inner\+\_\+product}関数で内積を計算できます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state\_ket(n);}
\DoxyCodeLine{    state\_ket.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    QuantumState state\_bra(n);}
\DoxyCodeLine{    state\_bra.set\_Haar\_random\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    std::complex<double> value = state::inner\_product(\&state\_ket, \&state\_bra);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\#\#\# 量子状態のデータの取得 量子状態を表す $2^n$ の長さの配列を取得します。 特に\+G\+P\+Uで量子状態を作成したり、大きい $n$ では非常に重い操作になるので注意してください。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// GNU C++の場合、double \_Complex配列を取得}}
\DoxyCodeLine{    \textcolor{comment}{// MSVCの場合はstd::complex<double>の配列を取得}}
\DoxyCodeLine{    \textcolor{keyword}{const} CTYPE* raw\_data\_c = state.data\_c();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// std::complex<double>の配列を取得}}
\DoxyCodeLine{    \textcolor{keyword}{const} CPPCTYPE* raw\_data\_cpp = state.data\_cpp();}
\DoxyCodeLine{\}}
\end{DoxyCode}


量子状態を直接指定の配列にセットしたい場合などは、該当する量子ゲートを作成し、量子ゲートの作用として行うことを推奨します。

\subsection*{量子ゲート}

\subsubsection*{量子ゲートの生成と作用}

デフォルトで実装されている量子ゲートはgate\+\_\+factoryの関数を通じて生成され、量子状態のポインタを引数として作用させられます。gate\+\_\+factoryで生成した量子ゲートは自動では解放されないため、ユーザが解放しなければいけません。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Xゲートの作用}}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_gate = gate::X(index);}
\DoxyCodeLine{    x\_gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// YでのPI/2回転}}
\DoxyCodeLine{    \textcolor{keywordtype}{double} angle = M\_PI / 2.0;}
\DoxyCodeLine{    \textcolor{keyword}{auto} ry\_gate = gate::RY(index, angle);}
\DoxyCodeLine{    ry\_gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{delete} x\_gate;}
\DoxyCodeLine{    \textcolor{keyword}{delete} ry\_gate;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\ttfamily gate}名前空間で定義されているゲートは以下の通りです。
\begin{DoxyItemize}
\item single-\/qubit Pauli operation\+: Identity, X,Y,Z
\item single-\/qubit Clifford operation \+: H,S,Sdag, T,Tdag,sqrtX,sqrt\+Xdag,sqrtY,sqrt\+Ydag
\item two-\/qubit Clifford operation \+: C\+N\+OT, CZ, S\+W\+AP
\item single-\/qubit Pauli rotation \+: RX, RY, RZ
\item General Pauli operation \+: Pauli, Pauli\+Rotation
\item I\+B\+MQ basis-\/gate \+: U1, U2, U3
\item General gate \+: Dense\+Matrix
\item Measurement \+: Measurement
\item Noise \+: Bit\+Flip\+Noise, Dephasing\+Noise, Indepenedent\+X\+Z\+Noise, Depolarizing\+Noise
\end{DoxyItemize}

\subsubsection*{量子ゲートの合成}

量子ゲートを合成し、新たな量子ゲートを生成できます。 合成したゲートは自身で解放しなければいけません。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_gate = gate::X(index);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} angle = M\_PI / 2.0;}
\DoxyCodeLine{    \textcolor{keyword}{auto} ry\_gate = gate::RY(index, angle);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// X, RYの順番に作用するゲートの作成}}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_and\_ry\_gate = gate::merge(x\_gate, ry\_gate);}
\DoxyCodeLine{}
\DoxyCodeLine{    x\_and\_ry\_gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{delete} x\_gate;}
\DoxyCodeLine{    \textcolor{keyword}{delete} ry\_gate;}
\DoxyCodeLine{    \textcolor{keyword}{delete} x\_and\_ry\_gate;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{量子ゲートのゲート行列の和}

量子ゲートのゲート要素の和を取ることができます。 (control-\/qubitがある場合の和は現状動作が未定義なので利用しないでください。) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate00 = gate::merge(gate::P0(0), gate::P0(1));}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate11 = gate::merge(gate::P1(0), gate::P1(1));}
\DoxyCodeLine{    \textcolor{comment}{// |00><00| + |11><11|}}
\DoxyCodeLine{    \textcolor{keyword}{auto} proj\_00\_or\_11 = gate::add(gate00, gate11);}
\DoxyCodeLine{    std::cout << proj\_00\_or\_11 << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate\_ii\_zz = gate::add(gate::Identity(0), gate::merge(gate::Z(0), gate::Z(1)));}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate\_ii\_xx = gate::add(gate::Identity(0), gate::merge(gate::X(0), gate::X(1)));}
\DoxyCodeLine{    \textcolor{keyword}{auto} proj\_00\_plus\_11 = gate::merge(gate\_ii\_zz, gate\_ii\_xx);}
\DoxyCodeLine{    \textcolor{comment}{// ((|00>+|11>)(<00|+<11|))/2 = (II + ZZ)(II + XX)/4}}
\DoxyCodeLine{    proj\_00\_plus\_11->multiply\_scalar(0.25);}
\DoxyCodeLine{    std::cout << proj\_00\_plus\_11 << std::endl;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{特殊な量子ゲートと一般の量子ゲート}

cppsimにおける基本量子ゲートは以下の二つに分けられます。
\begin{DoxyItemize}
\item 特殊ゲート：そのゲートの作用について、専用の高速化がなされた関数があるもの。
\item 一般ゲート：ゲート行列を保持し、行列をかけて作用するもの。
\end{DoxyItemize}

前者は後者に比べ専用の関数が作成されているため高速ですが、コントロール量子ビットを増やすなど、量子ゲートの作用を変更する操作が後から行えません。 こうした変更をしたい場合、特殊ゲートを一般ゲートに変換してやらねばなりません。

これは{\ttfamily gate\+::convert\+\_\+to\+\_\+matrix\+\_\+gate}で実現できます。 以下がその例になります。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_gate = gate::X(index);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 1st-qubitが0の場合だけ作用するようにcontrol qubitを追加}}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_mat\_gate = gate::to\_matrix\_gate(x\_gate);}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} control\_index = 1;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} control\_with\_value = 0;}
\DoxyCodeLine{    x\_mat\_gate->add\_control\_qubit(control\_index, control\_with\_value);}
\DoxyCodeLine{}
\DoxyCodeLine{    x\_mat\_gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{delete} x\_gate;}
\DoxyCodeLine{    \textcolor{keyword}{delete} x\_mat\_gate;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


専用の量子ゲートの一覧については\+A\+P\+Iドキュメントをご覧ください。

\subsubsection*{量子ゲートのゲート行列の取得}

生成した量子ゲートのゲート行列を取得できます。control量子ビットなどはゲート行列に含まれません。特にゲート行列を持たない種類のゲート（例えばn-\/qubitのパウリ回転ゲート）などは取得に非常に大きなメモリと時間を要するので気を付けてください。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_gate = gate::X(index);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 行列要素の取得}}
\DoxyCodeLine{    \textcolor{comment}{// ComplexMatrixはEigen::MatrixXcdでRowMajorにした複素行列型}}
\DoxyCodeLine{    ComplexMatrix matrix;}
\DoxyCodeLine{    x\_gate->set\_matrix(matrix);}
\DoxyCodeLine{    std::cout << matrix << std::endl;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{量子ゲートの情報の取得}

{\ttfamily ostream}に流し込むことで、量子ゲートのデバッグ情報を表示できます。量子ゲートのゲート行列が非常に巨大な場合、とても時間がかかるので注意してください。専用関数を持つ量子ゲートは自身のゲート行列は表示しません。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_gate = gate::X(index);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::cout << x\_gate << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{delete} x\_gate;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{一般的な量子ゲートの実現}

cppsimでは量子情報における種々のマップを以下の形で実現します。

\paragraph*{ユニタリ操作}

量子ゲートとして実現します。

\paragraph*{射影演算子やクラウス演算子など}

量子ゲートとして実現します。一般に作用後に量子状態のノルムは保存されません。{\ttfamily Dense\+Matrix}関数により生成できます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_general.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    ComplexMatrix one\_qubit\_matrix(2, 2);}
\DoxyCodeLine{    one\_qubit\_matrix << 0, 1, 1, 0;}
\DoxyCodeLine{    \textcolor{keyword}{auto} one\_qubit\_gate = gate::DenseMatrix(0, one\_qubit\_matrix);}
\DoxyCodeLine{    std::cout << one\_qubit\_gate << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    ComplexMatrix two\_qubit\_matrix(4,4);}
\DoxyCodeLine{    two\_qubit\_matrix <<}
\DoxyCodeLine{        1, 0, 0, 0,}
\DoxyCodeLine{        0, 1, 0, 0,}
\DoxyCodeLine{        0, 0, 0, 1,}
\DoxyCodeLine{        0, 0, 1, 0;}
\DoxyCodeLine{    \textcolor{keyword}{auto} two\_qubit\_gate = gate::DenseMatrix(\{0,1\}, two\_qubit\_matrix);}
\DoxyCodeLine{    std::cout << two\_qubit\_gate << std::endl;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\paragraph*{確率的なユニタリ操作}

{\ttfamily Probabilistic}関数を用いて、複数のユニタリ操作と確率分布を与えて作成します。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_general.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} x\_gate = gate::X(index);}
\DoxyCodeLine{    \textcolor{keyword}{auto} z\_gate = gate::Z(index);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} probabilistic\_xz\_gate = gate::Probabilistic(\{ x\_gate,z\_gate \}, \{ 0.1,0.2 \});}
\DoxyCodeLine{    \textcolor{keyword}{auto} depolarizing\_gate = gate::DepolarizingNoise(0.3);}
\DoxyCodeLine{}
\DoxyCodeLine{    depolarizing\_gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{    probabilistic\_xz\_gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\paragraph*{C\+P\+T\+P-\/map}

{\ttfamily C\+P\+TP}関数に完全性を満たすクラウス演算子のリストとして与えて作成します。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_general.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} p0 = gate::P0(index);}
\DoxyCodeLine{    \textcolor{keyword}{auto} p1\_fix = gate::merge(gate::P1(index), gate::X(index));}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} correction = gate::CPTP(\{p0,p1\_fix\});}
\DoxyCodeLine{    \textcolor{keyword}{auto} noise = gate::BitFlipNoise(index,0.1);}
\DoxyCodeLine{}
\DoxyCodeLine{    noise->update\_quantum\_state(\&state);}
\DoxyCodeLine{    correction->update\_quantum\_state(\&state);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\paragraph*{P\+O\+VM}

数値計算上には\+Instrumentと同じなので、\+Instrumentとして実現します。

\paragraph*{Instrument}

Instrumentは一般の\+C\+P\+T\+P-\/mapの操作に加え、ランダムに作用したクラウス演算子の添え字を取得する操作です。例えば、\+Z基底での測定は{\ttfamily P0}と{\ttfamily P1}からなる\+C\+P\+T\+P-\/mapを作用し、どちらが作用したかを知ることに相当します。 cppsimでは{\ttfamily Instrument}関数に\+C\+P\+T\+P-\/mapの情報と、作用したクラウス演算子の添え字を書きこむ古典レジスタのアドレスを指定することで実現します。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_general.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate00 = gate::merge(gate::P0(0), gate::P0(1));}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate01 = gate::merge(gate::P0(0), gate::P1(1));}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate10 = gate::merge(gate::P1(0), gate::P0(1));}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate11 = gate::merge(gate::P1(0), gate::P1(1));}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<QuantumGateBase*> gate\_list = \{ gate00, gate01, gate10, gate11 \};}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} classical\_pos = 0;}
\DoxyCodeLine{    \textcolor{keyword}{auto} gate = gate::Instrument(gate\_list, classical\_pos);}
\DoxyCodeLine{}
\DoxyCodeLine{    QuantumState state(2);}
\DoxyCodeLine{    state.set\_Haar\_random\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    std::cout << state << std::endl;}
\DoxyCodeLine{    gate->update\_quantum\_state(\&state);}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} result = state.get\_classical\_value(classical\_pos);}
\DoxyCodeLine{    std::cout << state << std::endl;}
\DoxyCodeLine{    std::cout << result << std::endl;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\paragraph*{Adaptive}

古典レジスタに書き込まれた値に応じて操作を行ったり行わなかったりします。cppsimでは{\ttfamily \mbox{[}unsigned int\mbox{]}}型のレジスタを引数として受け取り、{\ttfamily bool}型を返す関数を指定し、これを実現します。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define \_USE\_MATH\_DEFINES}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_merge.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_matrix.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_general.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} index = 3;}
\DoxyCodeLine{    \textcolor{keyword}{auto} h = gate::H(index);}
\DoxyCodeLine{    h->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} meas = gate::Measurement(index,0);}
\DoxyCodeLine{    meas->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} condition = [](\textcolor{keyword}{const} std::vector<UINT> reg)\{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} reg[0]==1;}
\DoxyCodeLine{    \};}
\DoxyCodeLine{    \textcolor{keyword}{auto} correction = gate::Adaptive(gate::X(index), condition);}
\DoxyCodeLine{    correction->update\_quantum\_state(\&state);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\paragraph*{C\+P-\/map}

Kraus-\/rankが1の場合は、上記の単体のクラウス演算子として扱ってください。それ以外の場合は、\+T\+Pになるようにクラウス演算子を調整した後、{\ttfamily multiply\+\_\+scalar}関数で定数倍にした{\ttfamily Identity}オペレータを作用するなどして調整してください。

\subsection*{量子回路}

\subsubsection*{量子回路の構成}

量子回路は量子ゲートの集合として表されます。 例えば以下のように量子回路を構成できます。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/circuit.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    state.set\_zero\_state();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 量子回路を定義}}
\DoxyCodeLine{    QuantumCircuit circuit(n);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 量子回路にゲートを追加}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<n;++i)\{}
\DoxyCodeLine{        circuit.add\_H\_gate(i);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 自身で定義したゲートも追加できる}}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<n;++i)\{}
\DoxyCodeLine{        circuit.add\_gate(gate::H(i));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 量子回路を状態に作用}}
\DoxyCodeLine{    circuit.update\_quantum\_state(\&state);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


なお、{\ttfamily add\+\_\+gate}で追加された量子回路は量子回路の解放時に一緒に解放されます。従って、代入したゲートは再利用できません。 引数として与えたゲートを再利用したい場合は、{\ttfamily add\+\_\+gate\+\_\+copy}関数を用いてください。ただしこの場合自身でゲートを解放する必要があります。

\subsubsection*{量子回路の最適化}

量子ゲートをまとめて一つの量子ゲートとすることで、量子ゲートの数を減らすことができ、数値計算の時間を短縮できることがあります。（もちろん、対象となる量子ビットの数が増える場合や、専用関数を持つ量子ゲートを合成して専用関数を持たない量子ゲートにしてしまった場合は、トータルで計算時間が減少するかは状況に依ります。）

下記のコードでは{\ttfamily optimize}関数を用いて、量子回路の量子ゲートをターゲットとなる量子ビットが3つになるまで貪欲法で合成を繰り返します。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/circuit.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/circuit\_optimizer.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} depth = 10;}
\DoxyCodeLine{    QuantumCircuit circuit(n);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = 0; d < depth; ++d) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; ++i) \{}
\DoxyCodeLine{            circuit.add\_gate(gate::H(i));}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 量子回路の最適化}}
\DoxyCodeLine{    QuantumCircuitOptimizer opt;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} max\_block\_size = 3;}
\DoxyCodeLine{    opt.optimize(\&circuit, max\_block\_size);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\end{DoxyCode}


\subsubsection*{量子回路の情報デバッグ}

量子ゲートと同様、量子回路も{\ttfamily ostream}に流し込むことでデバッグ情報を表示することができます。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/gate\_factory.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/circuit.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} depth = 10;}
\DoxyCodeLine{    QuantumCircuit circuit(n);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = 0; d < depth; ++d) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; ++i) \{}
\DoxyCodeLine{            circuit.add\_gate(gate::H(i));}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// 量子回路の情報を出力}}
\DoxyCodeLine{    std::cout << circuit << std::endl;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsection*{オブザーバブル}

\subsubsection*{オブザーバブルの生成}

オブザーバブルはパウリ演算子の集合として表現されます。 パウリ演算子は下記のように定義できます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/observable.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    \textcolor{keywordtype}{double} coef = 2.0;}
\DoxyCodeLine{    std::string Pauli\_string = \textcolor{stringliteral}{"X 0 X 1 Y 2 Z 4"};}
\DoxyCodeLine{    Observable observable(n);}
\DoxyCodeLine{    observable.add\_operator(coef,Pauli\_string.c\_str());}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{Open\+Fermionとの連携}

また、\+Open\+Fermionを用いて生成された以下のようなフォーマットのファイルから, オブザーバブルを生成することができます。このとき、オブザーバブルはそれを構成するのに必要最小限の大きさとなります。例えば、以下のようなopenfermionを用いて得られたオブザーバブルを読み込み、オブザーバブルを生成することが可能です。 
\begin{DoxyCode}{0}
\DoxyCodeLine{from openfermion.ops import FermionOperator}
\DoxyCodeLine{from openfermion.transforms import bravyi\_kitaev}
\DoxyCodeLine{}
\DoxyCodeLine{h\_00 = h\_11 = -1.252477}
\DoxyCodeLine{h\_22 = h\_33 = -0.475934}
\DoxyCodeLine{h\_0110 = h\_1001 = 0.674493}
\DoxyCodeLine{h\_2332 = h\_3323 = 0.697397}
\DoxyCodeLine{h\_0220 = h\_0330 = h\_1221 = h\_1331 = h\_2002 = h\_3003 = h\_2112 = h\_3113 = 0.663472}
\DoxyCodeLine{h\_0202 = h\_1313 = h\_2130 = h\_2310 = h\_0312 = h\_0132 = 0.181287}
\DoxyCodeLine{}
\DoxyCodeLine{fermion\_operator = FermionOperator('0\string^ 0', h\_00)}
\DoxyCodeLine{fermion\_operator += FermionOperator('1\string^ 1', h\_11)}
\DoxyCodeLine{fermion\_operator += FermionOperator('2\string^ 2', h\_22)}
\DoxyCodeLine{fermion\_operator += FermionOperator('3\string^ 3', h\_33)}
\DoxyCodeLine{}
\DoxyCodeLine{fermion\_operator += FermionOperator('0\string^ 1\string^ 1 0', h\_0110)}
\DoxyCodeLine{fermion\_operator += FermionOperator('2\string^ 3\string^ 3 2', h\_2332)}
\DoxyCodeLine{fermion\_operator += FermionOperator('0\string^ 3\string^ 3 0', h\_0330)}
\DoxyCodeLine{fermion\_operator += FermionOperator('1\string^ 2\string^ 2 1', h\_1221)}
\DoxyCodeLine{}
\DoxyCodeLine{fermion\_operator += FermionOperator('0\string^ 2\string^ 2 0', h\_0220-h\_0202)}
\DoxyCodeLine{fermion\_operator += FermionOperator('1\string^ 3\string^ 3 1', h\_1331-h\_1313)}
\DoxyCodeLine{}
\DoxyCodeLine{fermion\_operator += FermionOperator('0\string^ 1\string^ 3 2', h\_0132)}
\DoxyCodeLine{fermion\_operator += FermionOperator('2\string^ 3\string^ 1 0', h\_0132)}
\DoxyCodeLine{}
\DoxyCodeLine{fermion\_operator += FermionOperator('0\string^ 3\string^ 1 2', h\_0312)}
\DoxyCodeLine{fermion\_operator += FermionOperator('2\string^ 1\string^ 3 0', h\_0312)}
\DoxyCodeLine{}
\DoxyCodeLine{\#\# Bravyi-Kitaev transformation}
\DoxyCodeLine{bk\_operator = bravyi\_kitaev(fermion\_operator)}
\DoxyCodeLine{}
\DoxyCodeLine{\#\# output}
\DoxyCodeLine{fp = open("H2.txt", 'w')}
\DoxyCodeLine{fp.write(str(bk\_operator))}
\DoxyCodeLine{fp.close()}
\end{DoxyCode}
 このとき、上のpythonコードで生成された{\ttfamily H2.\+txt}ファイルは以下のような形式になっています。 
\begin{DoxyCode}{0}
\DoxyCodeLine{(-0.8126100000000005+0j) [] +}
\DoxyCodeLine{(0.04532175+0j) [X0 Z1 X2] +}
\DoxyCodeLine{(0.04532175+0j) [X0 Z1 X2 Z3] +}
\DoxyCodeLine{(0.04532175+0j) [Y0 Z1 Y2] +}
\DoxyCodeLine{(0.04532175+0j) [Y0 Z1 Y2 Z3] +}
\DoxyCodeLine{(0.17120100000000002+0j) [Z0] +}
\DoxyCodeLine{(0.17120100000000002+0j) [Z0 Z1] +}
\DoxyCodeLine{(0.165868+0j) [Z0 Z1 Z2] +}
\DoxyCodeLine{(0.165868+0j) [Z0 Z1 Z2 Z3] +}
\DoxyCodeLine{(0.12054625+0j) [Z0 Z2] +}
\DoxyCodeLine{(0.12054625+0j) [Z0 Z2 Z3] +}
\DoxyCodeLine{(0.16862325+0j) [Z1] +}
\DoxyCodeLine{(-0.22279649999999998+0j) [Z1 Z2 Z3] +}
\DoxyCodeLine{(0.17434925+0j) [Z1 Z3] +}
\DoxyCodeLine{(-0.22279649999999998+0j) [Z2]}
\end{DoxyCode}
 このような形式のファイルからオブザーバブルを生成するには、以下のようにコンストラクタの引数にファイルのパスを渡してやります。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/observable.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    std::string filename = \textcolor{stringliteral}{"H2.txt"};}
\DoxyCodeLine{    Observable observable(filename);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsubsection*{オブザーバブルの評価}

状態に対してオブザーバブルの期待値を評価できます。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/observable.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n = 5;}
\DoxyCodeLine{    \textcolor{keywordtype}{double} coef = 2.0;}
\DoxyCodeLine{    std::string Pauli\_string = \textcolor{stringliteral}{"X 0 X 1 Y 2 Z 4"};}
\DoxyCodeLine{    Observable observable(n);}
\DoxyCodeLine{    observable.add\_operator(coef, Pauli\_string.c\_str());}
\DoxyCodeLine{    }
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    observable.get\_expectation\_value(\&state);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\#\#\# オブザーバブルの回転 オブザーバブル $H$の回転 $e^{i\theta H}$を\+Trotter展開によって行います。{\ttfamily num\+\_\+repeats}はデフォルト値では以下のコードのようになっていますが、ユーザがオプションで指定することが可能です。 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/circuit.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/observable.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    UINT n;}
\DoxyCodeLine{    UINT num\_repeats;}
\DoxyCodeLine{    \textcolor{keywordtype}{double} theta;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{double} res;}
\DoxyCodeLine{}
\DoxyCodeLine{    Observable observable(\textcolor{stringliteral}{"../test/cppsim/H2.txt"}); }
\DoxyCodeLine{    }
\DoxyCodeLine{    n = observable.get\_qubit\_count();}
\DoxyCodeLine{    QuantumState state(n);  }
\DoxyCodeLine{    state.set\_computational\_basis(0);}
\DoxyCodeLine{    }
\DoxyCodeLine{    QuantumCircuit circuit(n);}
\DoxyCodeLine{    num\_repeats = (UINT) std::ceil(theta * (\textcolor{keywordtype}{double})n* 100.);}
\DoxyCodeLine{    circuit.add\_hamiltonian\_rotation\_gate(observable, angle, num\_repeats);}
\DoxyCodeLine{    circuit.update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    res = observable.get\_expectation\_value(\&state);}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsection*{変分量子回路}

量子回路を\+Parametric\+Quantum\+Circuitクラスとして定義すると、通所の\+Quantum\+Circuitクラスの関数に加え、変分法を用いて量子回路を最適化するのに便利ないくつかの関数を利用することができます。

\subsubsection*{変分量子回路の利用例}

一つの回転角を持つ量子ゲート(X-\/rot, Y-\/rot, Z-\/rot, multi\+\_\+qubit\+\_\+pauli\+\_\+rotation)はパラメトリックな量子ゲートとして量子回路に追加することができます。パラメトリックなゲートとして追加された量子ゲートについては、量子回路の構成後にパラメトリックなゲート数を取り出したり、後から回転角を変更することができます。


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/state.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <vqcsim/parametric\_circuit.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppsim/utility.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{    \textcolor{keyword}{const} UINT n = 3;}
\DoxyCodeLine{    \textcolor{keyword}{const} UINT depth = 10;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// create n-qubit parametric circuit}}
\DoxyCodeLine{    ParametricQuantumCircuit* circuit = \textcolor{keyword}{new} ParametricQuantumCircuit(n);}
\DoxyCodeLine{    Random random;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (UINT d = 0; d < depth; ++d) \{}
\DoxyCodeLine{        \textcolor{comment}{// add parametric X,Y,Z gate with random initial rotation angle}}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (UINT i = 0; i < n; ++i) \{}
\DoxyCodeLine{            circuit->add\_parametric\_RX\_gate(i, random.uniform());}
\DoxyCodeLine{            circuit->add\_parametric\_RY\_gate(i, random.uniform());}
\DoxyCodeLine{            circuit->add\_parametric\_RZ\_gate(i, random.uniform());}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{comment}{// add neighboring two-qubit ZZ rotation}}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (UINT i = d \% 2; i + 1 < n; i+=2) \{}
\DoxyCodeLine{            circuit->add\_parametric\_multi\_Pauli\_rotation\_gate(\{ i,i + 1 \}, \{ 3,3 \}, random.uniform());}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// get parameter count}}
\DoxyCodeLine{    UINT param\_count = circuit->get\_parameter\_count();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// get current parameter, and set shifted parameter}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (UINT p = 0; p < param\_count; ++p) \{}
\DoxyCodeLine{        \textcolor{keywordtype}{double} current\_angle = circuit->get\_parameter(p);}
\DoxyCodeLine{        circuit->set\_parameter(p, current\_angle + random.uniform());}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// create quantum state and update}}
\DoxyCodeLine{    QuantumState state(n);}
\DoxyCodeLine{    circuit->update\_quantum\_state(\&state);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// output state and circuit info}}
\DoxyCodeLine{    std::cout << state << std::endl;}
\DoxyCodeLine{    std::cout << circuit << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// release quantum circuit}}
\DoxyCodeLine{    \textcolor{keyword}{delete} circuit;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 